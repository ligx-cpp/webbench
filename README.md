# webbench

整个程序我的大体思路是：
  首先用户输入完成的URL和要创建的clients数目，request模块从URL中提取主机名或IP地址和端口号并且生成相应http请求行和请求头部，然后将所获取的主机名和端口号传入socket模块中使用，然后进入本程序的核心模块bench模块循环创建子进程，通过子进程访问目的主机，达到测试网站压力的目的！
将来还可能会将本算法改进成为多线程形式，去增加post请求方法等等一些操



多线程程序虽然能够运行，但是由于TCP本身的问题，主动关闭连接的一方会进入time_wait状态，所以每次执行程序都要等待2MSL才能出结果。(大概2分钟左右的时间)出现这种状况的原理如下：

仔细思考下四次握手的最后一个ACK分节的发送。主动关闭连接者发出最后一个ACK确认分节，但是主动关闭连接者怎么知道被动关闭连接者最后是否收到了自己发的ACK呢？

如果主动关闭连接者发现自己发的ACK在网络中阻塞或者丢失，应当及时重新发送ACK到被动关闭连接者。

当主动关闭连接者发送ACK后，连接进入TIME_WAIT状态，在主动关闭连接一方看来，有两种情况：

1）ACK正确到达了被动关闭连接一方，超过2MSL时间后，认定被动关闭连接一方收到最后的ACK分节；

2）ACK由于某些原因没有按时到达被动关闭连接一方，此时，能保证ACK出问题最长的极限是一个MSL时间，而被动关闭连接一方给出重发FIN分节，也应该是在一个MSL周期保证能到达。

故要保证所有老的重复分节在网络中消逝：

假设有以下一个连接：

192.168.144.43：50000 TCP 192.168.144.44：12500

从192.168.144.43：50000给192.168.144.44：12500发的一个分节在某个路由器阻塞（路由循环？）停滞，一段时间后192.168.144.43：50000检测出分节“丢失”并重发了这个被阻塞的分节，并且192.168.144.44：12500收到这个重发的分节且这条连接很快被释放关闭。

假设这条连接立刻能被复用，正常建立连接==》

之前被阻塞的分节慢悠悠的到达了192.168.144.44：12500，且恰好确认序号一致（这种情况完全可能！），于是乎，新的连接被旧有的连接的废弃数据“污染”啦！

如何保证新连接不会被旧的连接的某个“被丢失”的分节所污染呢？==》

好吧，等个2MSL，保证所有旧的连接的分节，不论是正常的不正常的，都已经在网络中消逝了，这个旧连接才可被复用。

这就是TIME_WAIT

我们想一下过程：

客户端发起对某个服务端的连接请求，内核分配一个临时端口给客户端socket，然后发SYN包到服务端…

在五元组中，服务端IP、PORT是确定的，客户端IP也是确定的，协议也是确定的，只有客户端的临时PORT是内核分配的。

当客户端发起大量TCP连接，内核也会分配大量临时端口给这个客户端，并记录每次的连接（客户端断开连接进入TIME_WAIT）。

于是乎，当发起速度和连接断开速度足够快时（比最早的连接的2MSL提前），就会出现，大量连接虽然被四次握手正常释放，但是还处于TIME_WAIT状态。

端口是一个16bit的数值，最大也就是65535，当达到一定上限时，内核无法分配一个可用的临时端口给客户端，即无法建立客户端socket，无法分配一个协议地址（TCP协议地址=IP+PORT）给客户端，自然connect调用报错。

emmm…有点复杂，简单举个栗子。

假设端口是一个2bit的数值，只有0、1、2、3四个值。

当客户端发起请求时，内核首先为客户端分配端口0，组成连接：

192.168.144.X：0 TCP 192.168.144：44:12500

然后客户端断开连接，此连接进入TIME_WAIT状态。

然后客户端再次发起三个请求，内核依次分配1、2、3，组成连接：

192.168.144.X：1 TCP 192.168.144：44:12500

==》连接释放，进入TIME_WAIT

192.168.144.X：2 TCP 192.168.144：44:12500

==》连接释放，进入TIME_WAIT

192.168.144.X：3 TCP 192.168.144：44:12500

==》连接释放，进入TIME_WAIT

上述内容源自https://blog.csdn.net/test1280/article/details/80295435
博主讲的很好，也符合我的问题所以就引用一下
